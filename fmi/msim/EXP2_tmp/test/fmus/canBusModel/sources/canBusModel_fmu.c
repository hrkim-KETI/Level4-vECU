#include "canBusModel_macros.h"
/*
 * Copyright 2025 The MathWorks, Inc.
 *
 * File    : canBusModel_fmu.c
 *
 * Abstract:
 *      FMI target wrapper generated by Simulink.
 *
 */

/*==================*
 * Required defines *
 *==================*/

#ifndef MODEL
# error Must specify a model name.  Define MODEL=name.
#else
/* create generic macros that work with any model */
# define EXPAND_CONCAT(name1,name2) name1 ## name2
# define CONCAT(name1,name2) EXPAND_CONCAT(name1,name2)
# define MODEL_INITIALIZE CONCAT(MODEL,_initialize)
# define MODEL_STEP       CONCAT(MODEL,_step)
# define MODEL_TERMINATE  CONCAT(MODEL,_terminate)
# define RT_MDL_TYPE      RT_MODEL_canBusModel_T
#endif
#define QUOTE1(name) #name
#define QUOTE(name) QUOTE1(name)    /* need to expand name    */
/*==========*
 * Includes *
 *==========*/
#include <math.h>
#include <time.h>
#include <stdio.h>   /* optional for printf */
#include <string.h>  /* optional for strcmp */
#include "rtmodel.h" /* optional for automated builds */
#include "canBusModel.h"
#include "canBusModel_private.h"
#include "fmi2Functions.h"
#include "RTWCG_FMU_util.h"

/*====================*
 * External functions *
 *====================*/
extern void MODEL_INITIALIZE();
extern void MODEL_TERMINATE();
extern void MODEL_STEP();
/*==================================*
 * Global data local to this module *
 *==================================*/
const char *RT_MEMORY_ALLOCATION_ERROR = "memory allocation error"; 
typedef struct {
    /* Model data */
    RT_MDL_TYPE *S;
    fmi2EventInfo eventInfo;
    /* FMU data*/
    fmi2String instanceName;
    fmi2Type type;
    fmi2String GUID;
    fmi2String resourceLocation;
    const fmi2CallbackFunctions *functions;
    fmi2Boolean visible;
    fmi2Boolean loggingOn;
    fmi2Boolean initialized;
    fmi2Real time;
    /* Variable Indices */
    real_T **rList;
    real_T *rBuffer;
    int32_T **iList;
    int32_T *iBuffer;
    boolean_T **bList;
    char **sList;
    int32_T *sSize;
    /* Output Buffers */
    real_T *rOutput;
    int32_T *iOutput;
    boolean_T *bOutput;
    char **sOutput;
} FMUModelData;
FMUModelData *_instance = NULL;
typedef struct {
    ExtU_canBusModel_T ExternalInput;
    ExtY_canBusModel_T ExternalOutput;
    P_canBusModel_T Parameter;
    B_canBusModel_T blockBuffer;
    real_T rListBuffer[1];
    int32_T iListBuffer[3];
    char* sListBuffer[9];
    fmi2Real time;
} FMUInternalState;
void fmu_syncToBuffer(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
}
void fmu_syncFromBuffer(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
}
void fmu_LogOutput(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    strncpy(modelData->sOutput[0], modelData->sList[8], modelData->sSize[8]);
}
void fmu_RestoreOutput(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    strncpy(modelData->sList[8], modelData->sOutput[0], modelData->sSize[8]);
}
const char* fmu_resourceLocation(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    return (const char *)modelData->resourceLocation;
}

const void* fmu_callback(int fmuVersion) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    if(fmuVersion <= 2) {
       return (const void *)modelData->functions;
    }
    else {
       return NULL;
    }
}

int fmu_fmuVisible(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    return (int)modelData->visible;
}

int fmu_fmuLogging(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    return (int)modelData->loggingOn;
}

char* fmu_instanceName(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    return (char*)modelData->instanceName;
}

int fmu_restoreSimScapeInitialState(void) {
    return 0;
}
/*====================*
 *  Static functions  *
 *====================*/
static void rtOneStep(RT_MDL_TYPE *S) {
    (void)S;
    MODEL_STEP();
    fmu_RestoreOutput();
}
/*===============*
 * FMI functions *
 *===============*/

const char* fmi2GetTypesPlatform(void) {
    static char str[] = {'d','e','f','a','u','l','t','\0'};
    return str;
}

const char* fmi2GetVersion(void) {
    static char str[] = {'2','.','0','\0'};
    return str;
}

fmi2Status fmi2SetDebugLogging(fmi2Component c, fmi2Boolean loggingOn, size_t nCategories, const fmi2String categories[]) {  
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    (void)nCategories;
    (void)categories;

    modelData->loggingOn = loggingOn;
    return fmi2OK;
}

fmi2Component fmi2Instantiate(fmi2String instanceName, fmi2Type fmuType, fmi2String fmuGUID,
                            fmi2String fmuResourceLocation, const fmi2CallbackFunctions *functions,
                            fmi2Boolean visible, fmi2Boolean loggingOn) {

    FMUModelData *modelData = NULL;
    const char_T *errmsg = NULL;

    if (!functions->logger) {
        return NULL;
    } else if (!instanceName || strlen(instanceName) == 0) {
        functions->logger(functions->componentEnvironment, "?", fmi2Error, "error",
                "fmi2Instantiate: Missing instance name.");
        return NULL;
    } else if (!fmuGUID || strlen(fmuGUID) == 0) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Missing GUID.");
        return NULL;
    } else if (strcmp(fmuGUID, "{f0b5a363-af3d-cb91-bc4e-b7d9bfd21209}")) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Wrong GUID %s. Expected %s.", fmuGUID, "{f0b5a363-af3d-cb91-bc4e-b7d9bfd21209}");
        return NULL;
    }
    _instance = modelData = (FMUModelData*)calloc(1, sizeof(FMUModelData));
    if (!modelData) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Memory allocation error.");
        return NULL;
    }
    modelData->S = canBusModel_M;
    if (modelData->S == NULL) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "Memory allocation error during model registration");
        return NULL;
    }
    errmsg = (const char_T *) (rtmGetErrorStatus(modelData->S));
    if (errmsg != NULL) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "Error during model registration: %s\n", errmsg);
        MODEL_TERMINATE();
        return NULL;
    }
    modelData->eventInfo.newDiscreteStatesNeeded = fmi2False;
    modelData->eventInfo.terminateSimulation = fmi2False;
    modelData->eventInfo.nominalsOfContinuousStatesChanged = fmi2False;
    modelData->eventInfo.valuesOfContinuousStatesChanged = fmi2False;
    modelData->eventInfo.nextEventTimeDefined = fmi2False;
    modelData->eventInfo.nextEventTime = 0;
    
    modelData->instanceName = (fmi2String)calloc(strlen(instanceName)+1, sizeof(fmi2Char*));
    if (!modelData->instanceName) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Memory allocation error.");
        return NULL;
    }
    strcpy((char *)modelData->instanceName, (char *)instanceName);
    modelData->type = fmuType;
    modelData->GUID = (fmi2String)calloc(strlen(fmuGUID)+1, sizeof(fmi2Char*));
    if (!modelData->GUID) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Memory allocation error.");
        return NULL;
    }
    strcpy((char *)modelData->GUID, (char *)fmuGUID);
    if (fmuResourceLocation) {
        modelData->resourceLocation = uriToLocal(fmuResourceLocation);
        if (!modelData->resourceLocation) {
            functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                    "fmi2Instantiate: Memory allocation error.");
            return NULL;
        }
        else if (strlen(modelData->resourceLocation) == 0) {
            functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                    "fmi2Instantiate: uriToLocal cannot handle fmuResourceLocation.");
            return NULL;
        }
    } else {
        modelData->resourceLocation = fmuResourceLocation;
    }
    modelData->functions = functions;
    modelData->visible = visible;
    modelData->loggingOn = loggingOn;
    modelData->initialized = fmi2False;
    modelData->time = 0.0;
    /* initialize variables */
    if (rtmGetStopRequested(modelData->S)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                fmi2Error, "error", "stop requested in fmi2Instantiate");
        return NULL;
    }
    modelData->rList = (real_T**)calloc(1, sizeof(real_T*));
    if (!modelData->rList) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Memory allocation error.");
        return NULL;
    }
    modelData->iList = (int32_T**)calloc(3, sizeof(int32_T*));
    if (!modelData->iList) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Memory allocation error.");
        return NULL;
    }
    modelData->sList = (char**)calloc(9, sizeof(char*));
    if (!modelData->sList) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Memory allocation error.");
        return NULL;
    }
    modelData->sSize = (int32_T*)calloc(9, sizeof(int32_T));
    if (!modelData->sSize) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Memory allocation error.");
        return NULL;
    }
    modelData->sOutput = (char**)calloc(1, sizeof(char*));
    if (!modelData->sOutput) {
        functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
                "fmi2Instantiate: Memory allocation error.");
        return NULL;
    }
    modelData->sOutput[0] = (char*)calloc(256,sizeof(char));
    modelData->rList[0] = &(modelData->time);
    modelData->iList[0] = &(canBusModel_P.CanFDSpeed_bps);
    modelData->iList[1] = &(canBusModel_P.CanSpeed_bps);
    modelData->iList[2] = &(canBusModel_P.FixedStep_us);
    fmu_syncToBuffer();
    modelData->sList[0] = canBusModel_U.CAN_IN_1;
    modelData->sList[1] = canBusModel_U.CAN_IN_2;
    modelData->sList[2] = canBusModel_U.CAN_IN_3;
    modelData->sList[3] = canBusModel_U.CAN_IN_4;
    modelData->sList[4] = canBusModel_U.CAN_IN_5;
    modelData->sList[5] = canBusModel_U.CAN_IN_6;
    modelData->sList[6] = canBusModel_U.CAN_IN_7;
    modelData->sList[7] = canBusModel_U.CAN_IN_8;
    modelData->sList[8] = canBusModel_Y.CAN_OUT;
    modelData->sSize[0] = 256;
    modelData->sSize[1] = 256;
    modelData->sSize[2] = 256;
    modelData->sSize[3] = 256;
    modelData->sSize[4] = 256;
    modelData->sSize[5] = 256;
    modelData->sSize[6] = 256;
    modelData->sSize[7] = 256;
    modelData->sSize[8] = 256;

    return modelData;
}

void fmi2FreeInstance(fmi2Component c) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    const char_T *errStatus = NULL;
    
    if (!modelData) return;
    errStatus = (const char_T *) (rtmGetErrorStatus(modelData->S));
    
    if (errStatus != NULL && strcmp(errStatus, "Simulation finished")) {
        modelData->functions->logger(modelData->functions->componentEnvironment, 
                modelData->instanceName, fmi2Error, "error", "%s", errStatus);

        MODEL_TERMINATE();
        return;
    }    
    MODEL_TERMINATE();
    
    free((void*)modelData->instanceName);
    free((void*)modelData->GUID);
    free((void*)modelData->resourceLocation);
    free((void*)modelData->rList);
    free((void*)modelData->iList);
    free((void*)modelData->sList);
    free((void*)modelData->sSize);
    free((void*)modelData->sOutput[0]);
    free((void*)modelData->sOutput);
    free((void*)modelData);
}

fmi2Status fmi2SetupExperiment(fmi2Component c, fmi2Boolean toleranceDefined, fmi2Real tolerance,
                            fmi2Real startTime, fmi2Boolean stopTimeDefined, fmi2Real stopTime) {

    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    (void)toleranceDefined;
    (void)tolerance;
    (void)stopTimeDefined;
    (void)stopTime;

    if (fabs(startTime) > 1.0E-7) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                fmi2Error, "error", "start time is not zero.");
        return fmi2Error;
    }

    modelData->time = startTime;
    return fmi2OK;
}

fmi2Status fmi2EnterInitializationMode(fmi2Component c) {
   FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
   {MODEL_INITIALIZE();
    modelData->initialized = fmi2True;};
    (void)c;
    return fmi2OK;
}

fmi2Status fmi2ExitInitializationMode(fmi2Component c) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    /* call step after setting input variables*/
    rtOneStep(modelData->S);;
    if (rtmGetStopRequested(modelData->S)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                fmi2Error, "error", "stop requested in fmi2ExitInitializationMode");
        return fmi2Error;
    }
    return fmi2OK;
}

fmi2Status fmi2Terminate(fmi2Component c) {
    (void)c;
    return fmi2OK;
}

fmi2Status fmi2Reset(fmi2Component c) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    const char_T *errmsg = (const char_T *) (rtmGetErrorStatus(modelData->S));
    /* Reset model data */
    if (errmsg != NULL && strcmp(errmsg, "Simulation finished")) {
        modelData->functions->logger(modelData->functions->componentEnvironment, 
                modelData->instanceName, fmi2Error, "error", "%s", errmsg);

        MODEL_TERMINATE();
        return fmi2Error;
    }    
    MODEL_TERMINATE();
    
    modelData->S = canBusModel_M;
    if (modelData->S == NULL) {
        modelData->functions->logger(modelData->functions->componentEnvironment, 
               modelData->instanceName, fmi2Error, "error",
               "Memory allocation error during model registration");
        return fmi2Error;
    }
    errmsg = (const char_T *) (rtmGetErrorStatus(modelData->S));
    if (errmsg != NULL) {
        modelData->functions->logger(modelData->functions->componentEnvironment, 
                modelData->instanceName, fmi2Error, "error",
                "Error during model registration: %s\n", errmsg);
        MODEL_TERMINATE();
        return fmi2Error;
    }
    modelData->eventInfo.newDiscreteStatesNeeded = fmi2False;
    modelData->eventInfo.terminateSimulation = fmi2False;
    modelData->eventInfo.nominalsOfContinuousStatesChanged = fmi2False;
    modelData->eventInfo.valuesOfContinuousStatesChanged = fmi2False;
    modelData->eventInfo.nextEventTimeDefined = fmi2False;
    modelData->eventInfo.nextEventTime = 0;
    modelData->rList[0] = &(modelData->time);
    modelData->iList[0] = &(canBusModel_P.CanFDSpeed_bps);
    modelData->iList[1] = &(canBusModel_P.CanSpeed_bps);
    modelData->iList[2] = &(canBusModel_P.FixedStep_us);
    fmu_syncToBuffer();
    modelData->sList[0] = canBusModel_U.CAN_IN_1;
    modelData->sList[1] = canBusModel_U.CAN_IN_2;
    modelData->sList[2] = canBusModel_U.CAN_IN_3;
    modelData->sList[3] = canBusModel_U.CAN_IN_4;
    modelData->sList[4] = canBusModel_U.CAN_IN_5;
    modelData->sList[5] = canBusModel_U.CAN_IN_6;
    modelData->sList[6] = canBusModel_U.CAN_IN_7;
    modelData->sList[7] = canBusModel_U.CAN_IN_8;
    modelData->sList[8] = canBusModel_Y.CAN_OUT;
    modelData->sSize[0] = 256;
    modelData->sSize[1] = 256;
    modelData->sSize[2] = 256;
    modelData->sSize[3] = 256;
    modelData->sSize[4] = 256;
    modelData->sSize[5] = 256;
    modelData->sSize[6] = 256;
    modelData->sSize[7] = 256;
    modelData->sSize[8] = 256;
    if (rtmGetStopRequested(modelData->S)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                fmi2Error, "error", "stop requested in fmi2Reset");
        return fmi2Error;
    }
    return fmi2OK;
}

fmi2Status fmi2GetReal (fmi2Component c, const fmi2ValueReference vr[], size_t nvr, fmi2Real value[]) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;
    if (nvr != 0 && (!value || !vr)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "invalid memory access");
        return fmi2Error;
    }
    fmu_syncToBuffer();
    for (i = 0; i < nvr; i++) {
        if (vr[i] >= 1.0) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "valueReference out of range");
            return fmi2Error;
        }
    }
    for (i = 0; i < nvr; i++) {
        value[i] = (fmi2Real)(*modelData->rList[vr[i]]);
        if (modelData->loggingOn) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
               fmi2OK, "info", "getReal vr:%d, value:%lf", vr[i], value[i]);
        }
    }
    return fmi2OK;
}

fmi2Status fmi2SetReal (fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2Real value[]) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;
    fmi2Boolean is_diff_value = fmi2False;
    if (nvr != 0 && (!value || !vr)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "invalid memory access");
        return fmi2Error;
    }
    for (i = 0; i < nvr; i++) {
        if (vr[i] >= 1.0) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "valueReference out of range");
            return fmi2Error;
        }
    }
    for (i = 0; i < nvr; i++) {
        if (*modelData->rList[vr[i]] != (real_T)(value[i])) {
            is_diff_value = fmi2True;
            *modelData->rList[vr[i]] = (real_T)(value[i]);
        }
        if (modelData->loggingOn) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
               fmi2OK, "info", "setReal vr:%d, value:%lf", vr[i], value[i]);
        }
    }
    fmu_syncFromBuffer();
    return fmi2OK;
}

fmi2Status fmi2GetInteger(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, fmi2Integer value[]) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;    
    if (nvr != 0 && (!value || !vr)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "invalid memory access");
        return fmi2Error;
    }
    fmu_syncToBuffer();
    for (i = 0; i < nvr; i++) {
        if (vr[i] >= 3.0) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "valueReference out of range");
            return fmi2Error;
        }
    }
    for (i = 0; i < nvr; i++) {
        value[i] = (fmi2Integer)(*modelData->iList[vr[i]]);
        if (modelData->loggingOn) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
               fmi2OK, "info", "getInteger vr:%d, value:%d", vr[i], value[i]);
        }
    }
    return fmi2OK;
}

fmi2Status fmi2SetInteger(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2Integer value[]) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;    
    fmi2Boolean is_diff_value = fmi2False;
    if (nvr != 0 && (!value || !vr)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "invalid memory access");
        return fmi2Error;
    }
    for (i = 0; i < nvr; i++) {
        if (vr[i] >= 3.0) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "valueReference out of range");
            return fmi2Error;
        }
    }
    for (i = 0; i < nvr; i++) {
        if (*modelData->iList[vr[i]] != (int32_T)(value[i])) {
            is_diff_value = fmi2True;
            *modelData->iList[vr[i]] = (int32_T)(value[i]);
        }
        if (modelData->loggingOn) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
               fmi2OK, "info", "setInteger vr:%d, value:%d", vr[i], value[i]);
        }
    }
    fmu_syncFromBuffer();
    return fmi2OK;
}

fmi2Status fmi2GetBoolean(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, fmi2Boolean value[]) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;    
    if (nvr != 0 && (!value || !vr)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "invalid memory access");
        return fmi2Error;
    }
    for (i = 0; i < nvr; i++) {
        if (vr[i] >= 0.0) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "valueReference out of range");
            return fmi2Error;
        }
    }
    for (i = 0; i < nvr; i++) {
        value[i] = (*modelData->bList[vr[i]] == false)?fmi2False:fmi2True;
        if (modelData->loggingOn) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
               fmi2OK, "info", "getBoolean vr:%d, value:%u", vr[i], value[i]);
        }
    }
    return fmi2OK;
}

fmi2Status fmi2SetBoolean(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2Boolean value[]) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;    
    fmi2Boolean is_diff_value = fmi2False;
    if (nvr != 0 && (!value || !vr)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "invalid memory access");
        return fmi2Error;
    }
    for (i = 0; i < nvr; i++) {
        if (vr[i] >= 0.0) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "valueReference out of range");
            return fmi2Error;
        }
    }
    for (i = 0; i < nvr; i++) {
        if (*modelData->bList[vr[i]] != ((value[i]==fmi2False)?false:true)) {
            is_diff_value = fmi2True;
            *modelData->bList[vr[i]] = (value[i]==fmi2False)?false:true;
        }
        if (modelData->loggingOn) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
               fmi2OK, "info", "setBoolean vr:%d, value:%u", vr[i], value[i]);
        }
    }
    return fmi2OK;
}

fmi2Status fmi2GetString (fmi2Component c, const fmi2ValueReference vr[], size_t nvr, fmi2String value[]) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;    
    if (nvr != 0 && (!value || !vr)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "invalid memory access");
        return fmi2Error;
    }
    for (i = 0; i < nvr; i++) {
        if (vr[i] >= 9.0) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "valueReference out of range");
            return fmi2Error;
        }
    }
    for (i = 0; i < nvr; i++) {
        value[i] = modelData->sList[vr[i]];
        if (modelData->loggingOn) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
               fmi2OK, "info", "getString vr:%d, value:%s", vr[i], value[i]);
        }
    }
    return fmi2OK;
}

fmi2Status fmi2SetString (fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2String value[]) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;    
    fmi2Boolean is_diff_value = fmi2False;
    size_t size;
    if (nvr != 0 && (!value || !vr)) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "invalid memory access");
        return fmi2Error;
    }
    for (i = 0; i < nvr; i++) {
       if (vr[i] >= 9.0) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "valueReference out of range");
            return fmi2Error;
        }
    }
    for (i = 0; i < nvr; i++) {
        if (strcmp(modelData->sList[vr[i]], value[i]) != 0) {
            is_diff_value = fmi2True;
            size = strlen(value[i]) < (modelData->sSize[vr[i]] - 1) ? strlen(value[i]) : (modelData->sSize[vr[i]] - 1);
            strncpy(modelData->sList[vr[i]], value[i], size);
            *((char*)modelData->sList[vr[i]]+size) = '\x00';
        }
        if (modelData->loggingOn) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
               fmi2OK, "info", "setString vr:%d, value:%s", vr[i], value[i]);
        }
    }
    return fmi2OK;
}

fmi2Status fmi2GetFMUstate(fmi2Component c, fmi2FMUstate* FMUstate) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    FMUInternalState* fmuInternalState = (FMUInternalState*)calloc(1, sizeof(FMUInternalState));
    memcpy(&fmuInternalState->ExternalInput, &canBusModel_U, sizeof(ExtU_canBusModel_T));
    memcpy(&fmuInternalState->ExternalOutput, &canBusModel_Y, sizeof(ExtY_canBusModel_T));
    memcpy(&fmuInternalState->Parameter, &canBusModel_P, sizeof(P_canBusModel_T));
    memcpy(&fmuInternalState->blockBuffer, &canBusModel_B, sizeof(B_canBusModel_T));
    for(size_t i = 0; i < 1; i++) {
        fmuInternalState->rListBuffer[i] = *modelData->rList[i];
    }
    for(size_t i = 0; i < 3; i++) {
       fmuInternalState->iListBuffer[i] = *modelData->iList[i];
    }
    for(size_t i = 0; i < 9; i++) {
        fmuInternalState->sListBuffer[i] = (char*)calloc(modelData->sSize[i],sizeof(char));
        strncpy(fmuInternalState->sListBuffer[i], modelData->sList[i], modelData->sSize[i]);
    }
    fmuInternalState->time = modelData->time;
    if (modelData->loggingOn) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
           fmi2OK, "info", "FMUstate saved at time %f.", modelData->time);
    }
    *FMUstate = (void*)(fmuInternalState);
    return fmi2OK;
}

fmi2Status fmi2SetFMUstate(fmi2Component c, fmi2FMUstate FMUstate) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    FMUInternalState* fmuInternalState = (FMUInternalState*)FMUstate;
    if (!modelData->initialized) {

        MODEL_INITIALIZE();
        modelData->initialized = fmi2True;
    }
    memcpy(&canBusModel_U, &fmuInternalState->ExternalInput, sizeof(ExtU_canBusModel_T));
    memcpy(&canBusModel_Y, &fmuInternalState->ExternalOutput, sizeof(ExtY_canBusModel_T));
    memcpy(&canBusModel_P, &fmuInternalState->Parameter, sizeof(P_canBusModel_T));
    memcpy(&canBusModel_B, &fmuInternalState->blockBuffer, sizeof(B_canBusModel_T));
    for(size_t i = 0; i < 1; i++) {
         *modelData->rList[i] = fmuInternalState->rListBuffer[i];
    }
    for(size_t i = 0; i < 3; i++) {
         *modelData->iList[i] = fmuInternalState->iListBuffer[i];
    }
    for(size_t i = 0; i < 9; i++) {
        strncpy(modelData->sList[i], fmuInternalState->sListBuffer[i], modelData->sSize[i]);
    }
    if (modelData->loggingOn) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
           fmi2OK, "info", "FMUstate restored at time %f.", fmuInternalState->time);
    }
    modelData->time = fmuInternalState->time;
    return fmi2OK;
}

fmi2Status fmi2FreeFMUstate(fmi2Component c, fmi2FMUstate* FMUstate) {
    FMUInternalState* fmuInternalState = (FMUInternalState*)*FMUstate;
    for(size_t i = 0; i < 9; i++) {
        free(fmuInternalState->sListBuffer[i]);
        fmuInternalState->sListBuffer[i] = NULL;
    }
    (void)c;
    free(*FMUstate);
    return fmi2OK;
}

fmi2Status fmi2SerializedFMUstateSize(fmi2Component c, fmi2FMUstate FMUstate, size_t *size) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    if (!FMUstate) {
        *size = 0;
    }
   *size = sizeof(FMUInternalState);
    for(size_t i = 0; i < 9; i++) {
        *size += modelData->sSize[i];
    }
    if (modelData->loggingOn) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
           fmi2OK, "info", "Serialized FMUState size: %d.", *size);
    }
   return fmi2OK;
}

fmi2Status fmi2SerializeFMUstate (fmi2Component c, fmi2FMUstate FMUstate, fmi2Byte serializedState[], size_t size) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t copiedSize = sizeof(FMUInternalState);
    FMUInternalState* fmuInternalState = (FMUInternalState*)FMUstate;
    memcpy(serializedState, (fmi2Byte*)fmuInternalState, sizeof(FMUInternalState));
    for(size_t i = 0; i < 9; i++) {
        memcpy(serializedState+copiedSize, (fmi2Byte*)fmuInternalState->sListBuffer[i], modelData->sSize[i]);
        copiedSize += modelData->sSize[i];
    }
    if (modelData->loggingOn) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
           fmi2OK, "info", "fmi2SerializeFMUstate");
    }
    if (size != copiedSize) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, fmi2Error, "error",
                "fmi2SerializeFMUstate: invalid FMUState size %d of %d.", copiedSize, size);
        return fmi2Error;
    }
   return fmi2OK;
}

fmi2Status fmi2DeSerializeFMUstate (fmi2Component c, const fmi2Byte serializedState[], size_t size,
                                    fmi2FMUstate* FMUstate) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t copiedSize = sizeof(FMUInternalState);
    if (!modelData->initialized) {

        MODEL_INITIALIZE();
        modelData->initialized = fmi2True;
    }
    FMUInternalState* fmuInternalState = (FMUInternalState*)calloc(1, sizeof(FMUInternalState));
    memcpy((char*)fmuInternalState, serializedState, sizeof(FMUInternalState));
    for(size_t i = 0; i < 9; i++) {
        fmuInternalState->sListBuffer[i] = (char*)calloc(modelData->sSize[i],sizeof(char));
        memcpy((char*)fmuInternalState->sListBuffer[i], serializedState+copiedSize, modelData->sSize[i]);
        copiedSize += modelData->sSize[i];
    }
    if (modelData->loggingOn) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
           fmi2OK, "info", "fmi2DeSerializeFMUstate");
    }
    if (size != copiedSize) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, fmi2Error, "error",
                "fmi2DeSerializeFMUstate: invalid FMUState size %d of %d.", copiedSize, size);
        return fmi2Error;
    }
    *FMUstate = fmuInternalState;
    return fmi2OK;
}

fmi2Status fmi2GetDirectionalDerivative(fmi2Component c, const fmi2ValueReference vUnknown_ref[], size_t nUnknown,
                                        const fmi2ValueReference vKnown_ref[] , size_t nKnown,
                                        const fmi2Real dvKnown[], fmi2Real dvUnknown[]) {
    (void)c;
    (void)vUnknown_ref;
    (void)nUnknown;
    (void)vKnown_ref;
    (void)nKnown;
    (void)dvKnown;
    (void)dvUnknown;
    return fmi2OK;
}

/* ---------------------------------------------------------------------------
 * Functions for FMI for Co-Simulation
 * ---------------------------------------------------------------------------
 */

/* Simulating the slave */
fmi2Status fmi2SetRealInputDerivatives(fmi2Component c, const fmi2ValueReference vr[], size_t nvr,
                                     const fmi2Integer order[], const fmi2Real value[]) {
    (void)c;
    (void)vr;
    (void)nvr;
    (void)order;
    (void)value;
    return fmi2OK;
}

fmi2Status fmi2GetRealOutputDerivatives(fmi2Component c, const fmi2ValueReference vr[], size_t nvr,
                                      const fmi2Integer order[], fmi2Real value[]) {
    size_t i;
    (void)c;
    (void)vr;
    (void)order;
    for (i = 0; i < nvr; i++) value[i] = 0;
    return fmi2OK;
}

fmi2Status fmi2CancelStep(fmi2Component c) {
    (void)c;
    return fmi2OK;
}

fmi2Status fmi2DoStep(fmi2Component c, fmi2Real currentCommunicationPoint,
                    fmi2Real communicationStepSize, fmi2Boolean noSetFMUStatePriorToCurrentPoint) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    int steps = 0;
    int i;
    fmi2Status returnStatus = fmi2OK;
    
    (void)noSetFMUStatePriorToCurrentPoint;
    steps = (int)(communicationStepSize / (double)0.001 + 0.5);    
    if (modelData->loggingOn) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
            fmi2OK, "info", "CommunicationStepSize=%.16g, LocalSolverStepSize=%.16g", communicationStepSize, (double)0.001);
    }
    if (communicationStepSize < 0 || fabs(communicationStepSize - steps * (double)0.001) > 1.0E-6 * (double)0.001) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "Stepsize must be non-negative and divisible by %.16g", (double)0.001);
        returnStatus = fmi2Error;
    } else if (fabs(modelData->time - currentCommunicationPoint) > 1.0E-6 * (double)0.001) {
        modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                    fmi2Error, "error", "CurrentCommunicationPoint is not equal to FMU time");
        returnStatus = fmi2Error;
    } else {
        modelData->time = currentCommunicationPoint;
        if (modelData->loggingOn) {
            modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                fmi2OK, "info", "Local solver will do %d steps from t = %.16g.", steps, currentCommunicationPoint);
        }
        for (i = 0; i < steps; i++) {
            if (rtmGetStopRequested(modelData->S)) {
                modelData->functions->logger(modelData->functions->componentEnvironment, modelData->instanceName, 
                        fmi2Error, "error", "stop requested in fmi2DoStep");
                returnStatus = fmi2Error;
                break;
            }
            rtOneStep(modelData->S);;
        }
        modelData->time += communicationStepSize;
    }
    
    if (modelData->functions->stepFinished) {
        modelData->functions->stepFinished(modelData->functions->componentEnvironment, returnStatus);
    }
    return returnStatus;
}

fmi2Status fmi2GetStatus(fmi2Component c, const fmi2StatusKind s, fmi2Status *value) {
    (void)c;
    (void)s;
    (void)value;
    return fmi2OK;
}

fmi2Status fmi2GetRealStatus(fmi2Component c, const fmi2StatusKind s, fmi2Real *value) {
    (void)c;
    (void)s;
    (void)value;
    return fmi2OK;
}

fmi2Status fmi2GetIntegerStatus(fmi2Component c, const fmi2StatusKind s, fmi2Integer *value) {
    (void)c;
    (void)s;
    (void)value;
    return fmi2OK;
}

fmi2Status fmi2GetBooleanStatus(fmi2Component c, const fmi2StatusKind s, fmi2Boolean *value) {
    (void)c;
    (void)s;
    (void)value;
    return fmi2OK;
}

fmi2Status fmi2GetStringStatus(fmi2Component c, const fmi2StatusKind s, fmi2String *value) {
    (void)c;
    (void)s;
    (void)value;
    return fmi2OK;
}

/* ---------------------------------------------------------------------------
 * Functions for FMI for Model Exchange
 * ---------------------------------------------------------------------------
 */

fmi2Status fmi2CompletedIntegratorStep(fmi2Component c, fmi2Boolean noSetFMUStatePriorToCurrentPoint, fmi2Boolean* enterEventMode, fmi2Boolean* terminateSimulation) {
    (void)c;
    (void)noSetFMUStatePriorToCurrentPoint;
    (void)enterEventMode;
    (void)terminateSimulation;
    return fmi2OK;
}

fmi2Status fmi2EnterContinuousTimeMode(fmi2Component c) {
    (void)c;
    return fmi2OK;
}

fmi2Status fmi2EnterEventMode(fmi2Component c) {
    (void)c;
    return fmi2OK;
}

fmi2Status fmi2GetContinuousStates(fmi2Component c, fmi2Real x[], size_t nx) {
    (void)c;
    (void)x;
    (void)nx;
    return fmi2OK;
}

fmi2Status fmi2GetDerivatives(fmi2Component c, fmi2Real derivatives[], size_t nx) {
    (void)c;
    (void)derivatives;
    (void)nx;
    return fmi2OK;
}

fmi2Status fmi2GetEventIndicators(fmi2Component c, fmi2Real eventIndicators[], size_t ni) {
    (void)c;
    (void)ni;
    (void)eventIndicators;
    return fmi2OK;
}

fmi2Status fmi2GetNominalsOfContinuousStates(fmi2Component c, fmi2Real x_nominal[], size_t nx) {
    (void)c;
    (void)x_nominal;
    (void)nx;
    return fmi2OK;
}

fmi2Status fmi2NewDiscreteStates(fmi2Component c, fmi2EventInfo* fmi2eventInfo) {
    (void)c;
    (void)fmi2eventInfo;
    return fmi2OK;
}

fmi2Status fmi2SetContinuousStates(fmi2Component c, const fmi2Real x[], size_t nx) {
    (void)c;
    (void)x;
    (void)nx;
    return fmi2OK;
}

fmi2Status fmi2SetTime(fmi2Component c, fmi2Real time) {
    (void)c;
    (void)time;
    return fmi2OK;
}
